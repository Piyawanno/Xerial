# Xerial Tutorial

Example code of this tutorial can be found in example directory.
In this tutorial, a simple table of **Person** will be implemented
and data in this table will be handled via Xerial.

## Connecting Database

Xerial uses JSON based configuration for connecting database.
For different database vendor, parameter in the JSON configuration is also different. In this tutorial, we use SQLite as database engine due to
the ease of environment setup. JSON configuration for other
database vendors can be found under [database connection configuration]().
Note that in an application we recommend to use [DBSessionPool]()
to make the application independent from database vendor.

To connect to SQLite :

```python
from xerial.SQLiteDBSession import SQLiteDBSession
from xerial.Vendor import Vendor

config = {
	"vendor" : Vendor.SQLITE,
	"database" : "./example.sqlite.bin"
}

session = SQLiteDBSession(config)
session.connect()
```

## Creating Model

The concept of Xerial is **"Code Centric"**. Hence, the structure of
database and table will be implemented in Python code to avoid
the external dependencies like a SQL file or additional procedure
to create database and table. As a result, the implemented code
can be deployed by just running the code. For this concept,
the structure of the database table will be implemented in **Model**.
In other words, Model contains the required meta data like columns
and table attributes.

```python
from xerial.Record import Record
from xerial.StringColumn import StringColumn
from xerial.IntegerColumn import IntegerColumn

class Person (Record) :
	# For StringColumn recommended length < 255
	name = StringColumn(length=64)
	surname = StringColumn(length=64)
	# StringColumn with length == -1 : LongText data type.
	address = StringColumn(length=-1)
	age = IntegerColumn(default=15)
```

Model is an inheritance of **Record** and consists of **Columns**.
In this case, we have a table called **Person**, which has 5 columns
namely *name*, *surname*, **address*, *age* and *id*.
The *id* column is the primary key column with type of integer
automatically generated by Xerial. You can also use other column
as primary key column. However, from our practical expertise,
we strongly recommend to use this default behavior of Xerial.
The table name of Model is set to the name of Model. In this case,
the table name will be **Person**. The table name can be customized
be defining **__tablename__** attribute of the class :

```python
class Person (Record) :
	__tablename__ = "OtherThanPerson"
```

This can be useful to avoid reserved words of SQL syntax.

Note that each column will be assigned as instance of **Column**
classes with defined attribute of each column. Xerial provides followed
type of Column  :

- IntegerColumn
- FloatColumn
- StringColumn
- DateColumn
- DateTimeColumn
- TimeColumn
- DayIntervalColumn
- JSONColumn

It can be seen that Xerial provides only a small set of column types.
This is another concept of Xerial that we intentionally keep things simple
and implemented just only things, which are needed in the practical
implementation.

After connecting database and creating model, the Model must be mapped
into database :

```python
from xerial.SQLiteDBSession import SQLiteDBSession
from xerial.Vendor import Vendor
from xerial.Record import Record
from xerial.StringColumn import StringColumn
from xerial.IntegerColumn import IntegerColumn

class Person (Record) :
	# For StringColumn recommended length < 255
	name = StringColumn(length=64)
	surname = StringColumn(length=64)
	# StringColumn with length == -1 : LongText data type.
	address = StringColumn(length=-1)
	age = IntegerColumn(default=15)

config = {
	"vendor" : Vendor.SQLITE,
	"database" : "./example.sqlite.bin"
}

session = SQLiteDBSession(config)
session.connect()
session.appendModel(Person)
session.createTable()
```

By saving the code under the name `Basic.py` and running the code,
you will get the result :

```bash
$ python3 Basic.py
$ sqlite3 example.sqlite.bin
SQLite version 3.31.1 2020-01-27 19:55:54
Enter ".help" for usage hints.
sqlite> .tables
Person
sqlite> .schema Person
CREATE TABLE Person (
         id INTEGER PRIMARY KEY AUTOINCREMENT,
        address TEXT   ,
        age INT   ,
        name VARCHAR(64)   ,
        surname VARCHAR(64)    );
sqlite>
```

It can be seen that table is automatically created according to
structure of **Person**. Moreover, Xerial will check the existence
of table and create table only by necessary. Hence, after implementation,
you can directly run the code on target environment and database structure
will be set. However, the modification of table structure is a sophisticated
topic and will be described in [Data Structure Modification]().
Firstly, for early stage of software development, you could drop a table
and rerun the code to get a modified structure in database.
For production stage or development stage with existing test data,
Data Structure Modification should be considered.

By calling `session.appendModel(Person)`, attributes of **Person** will be 
browsed and processed so that the meta-data will be extracted and separated
from the class. Afterwards, you can use **Person** as a regular class
with some pre-defined features. One of an useful feature is the default value.
If no default value is defined, the default value of each column will be set
to `None`. In our example, after `session.appendModel(Person)`, by
creating an instance of model, each column will have the default value :

```python
person = Person()
print(person.name, person.surname, person.address, person.age)
```

By running the code, you will get the result :

```bash
None None None 15
```

Since printing out attributes of Person is a frequently used feature,
we modify Person as followed :

```python
class Person (Record) :
	# For StringColumn recommended length < 255
	name = StringColumn(length=64)
	surname = StringColumn(length=64)
	# StringColumn with length == -1 : LongText data type.
	address = StringColumn(length=-1)
	age = IntegerColumn(default=15)

	# Column id is automatically generated.
	# If other primary key column is desired, column can be explicitly defined.
	def __repr__(self) -> str:
		return f"{self.id} {self.name} {self.surname} {self.age}"
```

## Inserting Data

To insert data, you can create an instance of Record, assign its attributes
and call method `session.insert()`.

```python
person = Person()
person.name = "Kittipong"
person.surname = "Piyawanno"
person.address = "Earth"
person.age = 10_000

session.insert(person)
```

Note that Xerial applies auto-commit and the primary key `person.id`
must not be assigned. After inserting data, it will be automatically
generated from database. Hence, by printing out `person.id`,
you will get the result :

```python
print(f"person.id : {person.id}")
```

```bash
$ python3 Basic.py
person.id : 1
```

If you want to manually assign primary key, you can set parameter
`isAutoID=False` by calling `session.insert()` :

```python
person = Person()
person.id = 2
person.name = "David"
person.surname = "Bowie"
person.address = "Mars"
person.age = 15_000

session.insert(person, isAutoID=False)
```

For the modern Web-based Application, web-server will usually get
data in form of JSON. You can assign attribute of instance of Record
using JSON by calling `fromDict` method.

```python
person = Person().fromDict({
	"name" : "Kurt",
	"surname" : "Cobain",
	"address" : "In Utero",
	"age" : 20_000
})

session.insert(person)
```

Note that method `fromDict` will return the object itself. This can be useful
for applying list comprehension, which can be used with method
`session.insertMultiple()` to insert multiple objects at the same time.

```python
session.insertMultiple([Person().fromDict(i) for i in data])
```

By default, `session.insertMultiple()` will not assign primary key to each object.
However, it has a significant better performance than `session.insert()`.
In some case, we can get performance gain of 10-20 time. Our recommendation :
Use `session.insertMultiple()` for massive data insertion without returning of
primary key. If you have to use primary key, you can set parameter
`isReturningID=True`. But note that, it is the same as calling `session.insert()`
for multiple time and no performance gain can be retrieved.

```python
session.insertMultiple([Person().fromDict(i) for i in data], isReturningID=True)
```

More over, like `session.insert()`, parameter `isAutoID=False` can also
set to `session.insertMultiple()`.

# Query data