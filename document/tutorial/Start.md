# Xerial Tutorial

Example code of this tutorial can be found in example directory.
In this tutorial, a simple table of **Person** will be implemented
and data in this table will be handled via Xerial.

## Connecting Database

Xerial uses JSON based configuration for connecting database.
For different database vendor, parameter in the JSON configuration is also different. In this tutorial, we use SQLite as database engine due to
the ease of environment setup. JSON configuration for other
database vendors can be found under [database connection configuration]().
Note that in an application we recommend to use [DBSessionPool]()
to make the application independent from database vendor.

To connect to SQLite :

```python
from xerial.SQLiteDBSession import SQLiteDBSession
from xerial.Vendor import Vendor

config = {
	"vendor" : Vendor.SQLITE,
	"database" : "./example.sqlite.bin"
}

session = SQLiteDBSession(config)
session.connect()
```

## Creating Model

The concept of Xerial is **"Code Centric"**. Hence, the structure of
database and table will be implemented in Python code to avoid
the external dependencies like a SQL file or additional procedure
to create database and table. As a result, the implemented code
can be deployed by just running the code. For this concept,
the structure of the database table will be implemented in **Model**.
In other words, Model contains the required meta data like columns
and table attributes.

```python
from xerial.Record import Record
from xerial.StringColumn import StringColumn
from xerial.IntegerColumn import IntegerColumn

class Person (Record) :
	# For StringColumn recommended length < 255
	name = StringColumn(length=64)
	surname = StringColumn(length=64)
	# StringColumn with length == -1 : LongText data type.
	address = StringColumn(length=-1)
	age = IntegerColumn(default=15)
```

Model is an inheritance of **Record** and consists of **Columns**.
In this case, we have a table called **Person**, which has 5 columns
namely *name*, *surname*, **address*, *age* and *id*.
The *id* column is the primary key column with type of integer
automatically generated by Xerial. You can also use other column
as primary key column. However, from our practical expertise,
we strongly recommend to use this default behavior of Xerial.
The table name of Model is set to the name of Model. In this case,
the table name will be **Person**. The table name can be customized
be defining **__tablename__** attribute of the class :

```python
class Person (Record) :
	__tablename__ = "OtherThanPerson"
```

This can be useful to avoid reserved words of SQL syntax.

Note that each column will be assigned as instance of **Column**
classes with defined attribute of each column. Xerial provides followed
type of Column  :

- IntegerColumn
- FloatColumn
- StringColumn
- DateColumn
- DateTimeColumn
- TimeColumn
- DayIntervalColumn
- JSONColumn

It can be seen that Xerial provides only a small set of column types.
This is another concept of Xerial that we intentionally keep things simple
and implemented just only things, which are needed in the practical
implementation.

After connecting database and creating model, the Model must be mapped
into database :

```python
from xerial.SQLiteDBSession import SQLiteDBSession
from xerial.Vendor import Vendor
from xerial.Record import Record
from xerial.StringColumn import StringColumn
from xerial.IntegerColumn import IntegerColumn

class Person (Record) :
	# For StringColumn recommended length < 255
	name = StringColumn(length=64)
	surname = StringColumn(length=64)
	# StringColumn with length == -1 : LongText data type.
	address = StringColumn(length=-1)
	age = IntegerColumn(default=15)

config = {
	"vendor" : Vendor.SQLITE,
	"database" : "./example.sqlite.bin"
}

session = SQLiteDBSession(config)
session.connect()
session.appendModel(Person)
session.createTable()
```

By saving the code under the name `Basic.py` and running the code,
you will get the result :

```bash
$ python3 Basic.py
$ sqlite3 example.sqlite.bin
SQLite version 3.31.1 2020-01-27 19:55:54
Enter ".help" for usage hints.
sqlite> .tables
Person
sqlite> .schema Person
CREATE TABLE Person (
         id INTEGER PRIMARY KEY AUTOINCREMENT,
        address TEXT   ,
        age INT   ,
        name VARCHAR(64)   ,
        surname VARCHAR(64)    );
sqlite>
```

It can be seen that table is automatically created according to
structure of **Person**. Moreover, Xerial will check the existence
of table and create table only by necessary. Hence, after implementation,
you can directly run the code on target environment and database structure
will be set. However, the modification of table structure is a sophisticated
topic and will be described in [Data Structure Modification]().
Firstly, for early stage of software development, you could drop a table
and rerun the code to get a modified structure in database.
For production stage or development stage with existing test data,
Data Structure Modification should be considered.

By calling `session.appendModel(Person)`, attributes of **Person** will be 
browsed and processed so that the meta-data will be extracted and separated
from the class. Afterwards, you can use **Person** as a regular class
with some pre-defined features. One of an useful feature is the default value.
If no default value is defined, the default value of each column will be set
to `None`. In our example, after `session.appendModel(Person)`, by
creating an instance of model, each column will have the default value :

```python
person = Person()
print(person.name, person.surname, person.address, person.age)
```

By running the code, you will get the result :

```bash
None None None 15
```

Since printing out attributes of Person is a frequently used feature,
we modify Person as followed :

```python
class Person (Record) :
	# For StringColumn recommended length < 255
	name = StringColumn(length=64)
	surname = StringColumn(length=64)
	# StringColumn with length == -1 : LongText data type.
	address = StringColumn(length=-1)
	age = IntegerColumn(default=15)

	# Column id is automatically generated.
	# If other primary key column is desired, column can be explicitly defined.
	def __repr__(self) -> str:
		return f"{self.id} {self.name} {self.surname} {self.age}"
```

## Inserting Data