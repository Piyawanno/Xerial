# Xerial Tutorial

Example code of this tutorial can be found in example directory.
In this tutorial, a simple table of **Person** will be implemented
and data in this table will be handled via Xerial.

## Connecting Database

Xerial uses JSON based configuration for connecting database.
For different database vendor, parameter in the JSON configuration is also different. In this tutorial, we use SQLite as database engine due to
the ease of environment setup. JSON configuration for other
database vendors can be found under [database connection configuration]().
Note that in an application we recommend to use [DBSessionPool]()
to make the application independent from database vendor.

To connect to SQLite :

```python
from xerial.SQLiteDBSession import SQLiteDBSession
from xerial.Vendor import Vendor

config = {
	"vendor" : Vendor.SQLITE,
	"database" : "./example.sqlite.bin"
}

session = SQLiteDBSession(config)
session.connect()
```

## Creating Model

The concept of Xerial is **"Code Centric"**. Hence, the structure of
database and table will be implemented in Python code to avoid
the external dependencies like a SQL file or additional procedure
to create database and table. As a result, the implemented code
can be deployed by just running the code. For this concept,
the structure of the database table will be implemented in **Model**.
In other words, Model contains the required meta data like columns
and table attributes.

```python
from xerial.Record import Record
from xerial.StringColumn import StringColumn
from xerial.IntegerColumn import IntegerColumn

class Person (Record) :
	# For StringColumn recommended length < 255
	name = StringColumn(length=64)
	surname = StringColumn(length=64)
	# StringColumn with length == -1 : LongText data type.
	address = StringColumn(length=-1)
	age = IntegerColumn(default=15)
```

Model is an inheritance of **Record** and consists of **Columns**.
In this case, we have a table called **Person**, which has 5 columns
namely *name*, *surname*, **address*, *age* and *id*.
The *id* column is the primary key column with type of integer
automatically generated by Xerial. You can also use other column
as primary key column. However, from our practical expertise,
we strongly recommend to use this default behavior of Xerial.
The table name of Model is set to the name of Model. In this case,
the table name will be **Person**. The table name can be customized
be defining **__tablename__** attribute of the class :

```python
class Person (Record) :
	__tablename__ = "OtherThanPerson"
```

This can be useful to avoid reserved words of SQL syntax.

Note that each column will be assigned as instance of
[**Column**](../api/xerial/Column.md)
classes with defined attribute of each column. Xerial provides followed
type of Column  :

- [IntegerColumn](../api/xerial/IntegerColumn.md)
- [FloatColumn](../api/xerial/FloatColumn.md)
- [StringColumn](../api/xerial/StringColumn.md)
- [DateColumn](../api/xerial/DateColumn.md)
- [DateTimeColumn](../api/xerial/DateTimeColumn.md)
- [TimeColumn](../api/xerial/TimeColumn.md)
- [DayIntervalColumn](../api/xerial/DayIntervalColumn.md)
- [JSONColumn](../api/xerial/JSONColumn.md)
- [CurrencyColumn](../api/xerial/CurrencyColumn.md)
- [FractionColumn](../api/xerial/FractionColumn.md)
- [MultiPointColumn](../api/xerial/MultiPointColumn.md)
- [PointColumn](../api/xerial/PointColumn.md)

It can be seen that Xerial provides only a small set of column types.
This is another concept of Xerial that we intentionally keep things simple
and implemented just only things, which are needed in the practical
implementation.

After connecting database and creating model, the Model must be mapped
into database :

```python
from xerial.SQLiteDBSession import SQLiteDBSession
from xerial.Vendor import Vendor
from xerial.Record import Record
from xerial.StringColumn import StringColumn
from xerial.IntegerColumn import IntegerColumn

class Person (Record) :
	# For StringColumn recommended length < 255
	name = StringColumn(length=64)
	surname = StringColumn(length=64)
	# StringColumn with length == -1 : LongText data type.
	address = StringColumn(length=-1)
	age = IntegerColumn(default=15)

config = {
	"vendor" : Vendor.SQLITE,
	"database" : "./example.sqlite.bin"
}

session = SQLiteDBSession(config)
session.connect()
session.appendModel(Person)
session.createTable()
```

By saving the code under the name `Basic.py` and running the code,
you will get the result :

```bash
$ python3 Basic.py
$ sqlite3 example.sqlite.bin
SQLite version 3.31.1 2020-01-27 19:55:54
Enter ".help" for usage hints.
sqlite> .tables
Person
sqlite> .schema Person
CREATE TABLE Person (
         id INTEGER PRIMARY KEY AUTOINCREMENT,
        address TEXT   ,
        age INT   ,
        name VARCHAR(64)   ,
        surname VARCHAR(64)    );
sqlite>
```

It can be seen that table is automatically created according to
structure of **Person**. Moreover, Xerial will check the existence
of table and create table only by necessary. Hence, after implementation,
you can directly run the code on target environment and database structure
will be set. However, the modification of table structure is a sophisticated
topic and will be described in [Data Structure Modification]().
Firstly, for early stage of software development, you could drop a table
and rerun the code to get a modified structure in database.
For production stage or development stage with existing test data,
Data Structure Modification should be considered.

By calling `session.appendModel(Person)`, attributes of **Person** will be 
browsed and processed so that the meta-data will be extracted and separated
from the class. Afterwards, you can use **Person** as a regular class
with some pre-defined features. One of an useful feature is the default value.
If no default value is defined, the default value of each column will be set
to `None`. In our example, after `session.appendModel(Person)`, by
creating an instance of model, each column will have the default value :

```python
person = Person()
print(person.name, person.surname, person.address, person.age)
```

By running the code, you will get the result :

```bash
None None None 15
```

Since printing out attributes of Person is a frequently used feature,
we modify Person as followed :

```python
class Person (Record) :
	# For StringColumn recommended length < 255
	name = StringColumn(length=64)
	surname = StringColumn(length=64)
	# StringColumn with length == -1 : LongText data type.
	address = StringColumn(length=-1)
	age = IntegerColumn(default=15)

	# Column id is automatically generated.
	# If other primary key column is desired, column can be explicitly defined.
	def __repr__(self) -> str:
		return f"{self.id} {self.name} {self.surname} {self.age}"
```

## Inserting Data

To insert data, you can create an instance of Record, assign its attributes
and call method `session.insert()`.

```python
person = Person()
person.name = "Kittipong"
person.surname = "Piyawanno"
person.address = "Earth"
person.age = 10_000

session.insert(person)
```

Note that Xerial applies auto-commit and the primary key `person.id`
must not be assigned. After inserting data, it will be automatically
generated from database. Hence, by printing out `person.id`,
you will get the result :

```python
print(f"person.id : {person.id}")
```

```bash
$ python3 Basic.py
person.id : 1
```

If you want to manually assign primary key, you can set parameter
`isAutoID=False` by calling `session.insert()` :

```python
person = Person()
person.id = 2
person.name = "David"
person.surname = "Bowie"
person.address = "Mars"
person.age = 15_000

session.insert(person, isAutoID=False)
```

For the modern Web-based Application, web-server will usually get
data in form of JSON. You can assign attribute of instance of Record
using JSON by calling `fromDict` method.

```python
person = Person().fromDict({
	"name" : "Kurt",
	"surname" : "Cobain",
	"address" : "In Utero",
	"age" : 20_000
})

session.insert(person)
```

Note that method `fromDict` will return the object itself. This can be useful
for applying list comprehension, which can be used with method
`session.insertMultiple()` to insert multiple objects at the same time.

```python
session.insertMultiple([Person().fromDict(i) for i in data])
```

By default, `session.insertMultiple()` will not assign primary key to each object.
However, it has a significant better performance than `session.insert()`.
In some case, we can get performance gain of 10-20 time. Our recommendation :
Use `session.insertMultiple()` for massive data insertion without returning of
primary key. If you have to use primary key, you can set parameter
`isReturningID=True`. But note that, it is the same as calling `session.insert()`
for multiple time and no performance gain can be retrieved.

```python
session.insertMultiple([Person().fromDict(i) for i in data], isReturningID=True)
```

Moreover, like `session.insert()`, parameter `isAutoID=False` can also
set to `session.insertMultiple()`.

## Query data

Data query should be the most frequently used of `DBSessionBase`.
Since the SQL has a powerful query clause, Xerial inherits this
capability nearby directly. The developer can use the `WHERE`, `ORDER BY`
and `GROUP BY` clause with the method `DBSessionBase.select`.

```python
name = 'Kurt'
clause = "WHERE name=? ORDER BY id DESC"
personList = session.select(Person, clause, parameter=[name])
```

The result of the method calls will be the list of `Person` complied
with the given WHERE clause. Note that in the example, the optional
parameter `parameter` is used to given the list of parameter in the placement
of `?` in the WHERE clause. The developer can directly give the parameter
directly into the WHERE clause :

```python
name = 'Kurt'
clause = f"WHERE name={name} ORDER BY id DESC"
personList = session.select(Person, clause)
```

However, this method is not recommended due to the security issue
with SQL injection.

To set the offset and the limit of the result, the parameter `limit`
and `offset` can be used. These parameters are useful for pagination
of the data. Note that, these parameters are set outside the `clause`
parameter, because SQL statement is different for each database vendor.

```python
name = 'Kurt'
clause = f"WHERE name=? ORDER BY id DESC"
personList = session.select(Person, clause, parameter=[name], limit=10, offset=20)
```

Other special use case but frequently used for data selection is
the method `selectByID`, where Record will be directly selected with the primary key

```python
person = session.selectByID(Person, ID=20)
```

The return value of this method call will be a single object of the class
`Person`, if the `ID=20` exists in the database. Otherwise, `None` will
be returned.

For the other usage of data selection, Xerial also provides methods with
data formats other than list of Records like :

- `selectRaw` : Returning the list of dictionary compatible with JSON.
This can increase performance by skipping the process of mapping from
data to Record object and back to JSON compatible data.
- `selectTranspose` : Resulting the dictionary of data list compatible
with JSON. The structure will be `{columnName: [value, ...]}`.
This is helpful for saving bandwidth between HTTP server and client in RESTFull fashion.
- `selectCSV` : The selected data will be written directly into the
given file with the CSV data format.
- `selectExcel` : The selected data will be written directly into the
given file with the Excel data format.

## Further Reading

For the relation between Model, Xerial provides the followed relation :

- [One-to-One Relation](OneToOneRelation.md)
- [One-to-Many Relation](OneToManyRelation.md)
- [Many-to-Many Relation](ManyToManyRelation.md)

Xerial also provide tools for data backup like :

- [Data dumping and restore with Xerial](DataDump.md)
- [Incremental data backup](IncremetalBackup.md)